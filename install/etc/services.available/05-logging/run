#!/command/with-contenv bash
#-----------------------------------------------------------------------------
# Container Logging Service Runtime Script
#
# Purpose: Manages the runtime execution of logging backends (Fluent Bit) for
#          container log shipping with automatic logrotate integration and
#          dynamic parser configuration
# Context: Runs as s6-overlay service after container initialization completes
# Note: This script handles Fluent Bit startup with dynamic log configuration
#-----------------------------------------------------------------------------



#-----------------------------------------------------------------------------
# SERVICE INITIALIZATION
#-----------------------------------------------------------------------------
# Source container core functions and prepare logging service
source /assets/functions/00-container
output_off
PROCESS_NAME="logging"
prepare_service defaults single
check_container_initialized
check_service_initialized init

#-----------------------------------------------------------------------------
# SCHEDULING DEPENDENCY CHECK
#-----------------------------------------------------------------------------
# Wait for cron service to start if scheduling is enabled
if var_true "${CONTAINER_ENABLE_SCHEDULING}" ; then
  print_debug "[logship] Waiting for Cron to start"
  counter=0
  timeout=60
  while ! pgrep crond > /dev/null ; do
    sleep 1
    counter=$((counter + 1))
    if [ $counter -ge $timeout ]; then
      print_error "[logship] Timeout waiting for cron service after ${timeout} seconds"
      exit 1
    fi
  done
  print_debug "[logship] Cron service started after ${counter} seconds"
fi

# Mark service initialization as complete
liftoff

#-----------------------------------------------------------------------------
# LOG SHIPPING BACKEND EXECUTION
#-----------------------------------------------------------------------------
# Execute log shipping backend based on configuration
case "${CONTAINER_LOGSHIPPING_BACKEND,,}" in
  "fluent-bit" | "fluentbit" )
  #-----------------------------------------------------------------------------
  # FLUENT BIT TAIL CONFIGURATION
  #-----------------------------------------------------------------------------
  # Configure tail input plugin parameters based on environment variables
  if var_true "${FLUENTBIT_TAIL_KEY_PATH_ENABLE}" ; then
    tail_key_path="    Path_Key          ${FLUENTBIT_TAIL_KEY_PATH}"
  fi

  if var_true "${FLUENTBIT_TAIL_KEY_OFFSET_ENABLE}" ; then
    tail_key_offset="    Offset_Key        ${FLUENTBIT_TAIL_KEY_OFFSET}"
  fi

  if [ -n "${FLUENTBIT_TAIL_IGNORE_OLDER}" ] ; then
    tail_ignore_older="    Ignore_Older      ${FLUENTBIT_TAIL_IGNORE_OLDER}"
  fi

  truefalse_onoff FLUENTBIT_TAIL_SKIP_EMPTY_LINES
  truefalse_onoff FLUENTBIT_TAIL_SKIP_LONG_LINES

  #-----------------------------------------------------------------------------
  # AUTOMATIC LOGRotate INTEGRATION
  #-----------------------------------------------------------------------------
  # Parse logrotate files to automatically configure log shipping
  if var_true "${LOGSHIPPING_AUTO_CONFIG_LOGROTATE}" ; then
    print_debug "[logship] Starting to parse logrotate files for log shipping"
    mkdir -p /tmp/.container/logship/
    
    # Only process if not already configured
    if [ ! -f "/tmp/.container/logship/logrotate" ]; then
      # Process each logrotate configuration file
      if [ -d "/etc/logrotate.d" ] && [ "$(find /etc/logrotate.d -maxdepth 1 -type f 2>/dev/null | wc -l)" -gt 0 ]; then
        for logrotate_file in /etc/logrotate.d/* ; do
        set -f
        
        # Initialize parser variables for each logrotate file
        multi_parsers=""
        multiple_parsers=""
        logrotate_parsers_full=""
        logrotate_parser=""
        skip_processing=""
        
        # Extract log file paths
        if [ -f "${logrotate_file}" ]; then
          logrotate_paths=$(grep '{' "${logrotate_file}" 2>/dev/null | cut -d { -f 1 | xargs | tr " " "\n" ; )
        else
          logrotate_paths=""
        fi
        
        # Process each log file path
        for logrotate_path in $logrotate_paths ; do
          # Skip if already configured
          if [ "$(find /etc/fluent-bit/conf.d -name "in_tail_*.conf" -type f 2>/dev/null | wc -l)" -eq 0 ] || ! grep -Fq "$logrotate_path" /etc/fluent-bit/conf.d/in_tail_*.conf >/dev/null 2>&1 ; then
            
            # Check logship parser directive
            if [ -f "${logrotate_file}" ] && grep -Fq "# logship:" "${logrotate_file}" >/dev/null 2>&1 ; then
              logrotate_parser=$(grep "# logship:" "${logrotate_file}" 2>/dev/null | cut -d : -f 2 | tr "," "\n" | xargs)
              
              # Handle multiple parser configuration
              if [ "$(echo "${logrotate_parser}" | wc -w)" -gt 1 ] ; then
                print_debug "[logship] Found Multiple parsers in logrotate configuration"
                multiple_parsers=TRUE
                logrotate_parsers_full=${logrotate_parser}
                
                # Build multiple parser configuration block
                multi_parsers=""
                for multi_parser in $logrotate_parsers_full; do
                  multi_parsers="${multi_parsers}
    Parser            ${multi_parser}"
                done
              fi
              
              # Process parser directive (skip/ignore or specific parser)
              case "$(echo "${logrotate_parser,,}" | awk '{print $1}')" in
                "skip" | "ignore" )
                  print_debug "[logship] Logrotate configuration is telling us to skip shipping logs for '$(basename "${logrotate_file}")'"
                  skip_processing=TRUE
                ;;
                * )
                  print_debug "[logship] Logrotate directed us to use the '${logrotate_parser}' parser for '$(basename "${logrotate_file}")'"
                  logrotate_parser="    Parser            $(echo "${logrotate_parser}" | awk '{print $1}')"
                ;;
              esac
            fi
            
            # Create log shipping configuration if not skipped
            if [ "${skip_processing}" != "TRUE" ]; then
              print_debug "[logship] Creating Log ship entry for '${logrotate_path}' to be parsed by '${CONTAINER_LOGSHIPPING_BACKEND}'"

              # Configure database tracking if enabled
              if var_true "${FLUENTBIT_TAIL_DB_ENABLE}" ; then
                tail_db=$(cat<<EOF
    DB                $(dirname ${logrotate_path})/.$(basename ${logrotate_path}).db
    DB.sync           ${FLUENTBIT_TAIL_DB_SYNC}
    DB.locking        ${FLUENTBIT_TAIL_DB_LOCK}
    DB.journal_mode   ${FLUENTBIT_TAIL_DB_JOURNAL_MODE}
EOF
                )
              fi

              # Generate Fluent Bit input configuration
              cat <<EOF >> "/etc/fluent-bit/conf.d/in_tail_$(basename "${logrotate_file,,}").conf"
# Log File Shipping created automatically generated by reading ${logrotate_file}
# Generated on $(TZ=${TIMEZONE} date +'%Y-%m-%d %H:%M:%S %Z')

[INPUT]
    Name              tail
    Path              ${logrotate_path}
    Tag               $(basename "${logrotate_file,,}")
    Buffer_Chunk_Size ${FLUENTBIT_TAIL_BUFFER_CHUNK_SIZE}
    Buffer_Max_Size   ${FLUENTBIT_TAIL_BUFFER_MAX_SIZE}
    Read_from_Head    ${FLUENTBIT_TAIL_READ_FROM_HEAD}
    Skip_Empty_Lines  ${FLUENTBIT_TAIL_SKIP_EMPTY_LINES}
    Skip_Long_Lines   ${FLUENTBIT_TAIL_SKIP_LONG_LINES}
${tail_key_path}
${logrotate_parser}
${tail_db}
${tail_ignore_older}
${tail_key_offset}
EOF
            fi
          fi
        done
        
        # Add metadata and parser filters only if config file exists
        if [ -f "/etc/fluent-bit/conf.d/in_tail_$(basename "${logrotate_file,,}").conf" ] ; then
          if ! grep -q 'record_modifier' "/etc/fluent-bit/conf.d/in_tail_$(basename "${logrotate_file,,}").conf" 2>/dev/null ; then
            cat <<EOF >> "/etc/fluent-bit/conf.d/in_tail_$(basename "${logrotate_file,,}").conf"

[FILTER]
    Name record_modifier
    Match $(basename "${logrotate_file,,}")
    Record container_name ${CONTAINER_NAME}
    Record product $(basename "${logrotate_file,,}")
    Record hostname $(hostname)
EOF
          fi

          # Add parser filter for multiple parser configurations
          if var_true "${multiple_parsers}" ; then
            if ! grep -q 'Reserve_Data' "/etc/fluent-bit/conf.d/in_tail_$(basename "${logrotate_file,,}").conf" 2>/dev/null ; then
              cat <<EOF >> "/etc/fluent-bit/conf.d/in_tail_$(basename "${logrotate_file,,}").conf"

[FILTER]
    Name            parser
    Match           $(basename "${logrotate_file,,}")
    Preserve_Key    Off
    Reserve_Data    On
    Key_Name        multilog
${multi_parsers}
EOF
            fi
          fi
        fi
        
        # Clean up parser variables for next iteration
        unset logrotate_parsers_full
        unset multiple_parsers
        unset multi_parsers
        unset logrotate_parser

        # Re-enable filename expansion after processing each logrotate file
        set +f
        done
      else
        print_debug "[logship] No logrotate configuration files found"
      fi
      
      # Fix path separators and mark configuration as complete
      if [ -n "$(ls -A /etc/fluent-bit/conf.d/ 2>/dev/null)" ]; then
        sed -i "s|//|/|g" /etc/fluent-bit/conf.d/*.conf
      fi
      touch /tmp/.container/logship/logrotate
    fi
  fi

  #-----------------------------------------------------------------------------
  # FLUENT BIT SERVICE STARTUP
  #-----------------------------------------------------------------------------
  # Start Fluent Bit with generated configuration
  print_start "[logship] Starting fluent-bit ${FLUENTBIT_VERSION}"
  silent exec fluent-bit -c /etc/fluent-bit/fluent-bit.conf
  ;;
esac
